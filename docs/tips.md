# 开发小记

此处记录开发中的碎碎念。

项目最初是仿照 [web-see](https://github.com/xy-sea/web-see.git) 设计的，借鉴了它的单例模式、上报去重、上报数据格式统一等思想。到了最后，笔者发现自己的项目与 web-see 极为相似，于是重新设计了这个项目，得到了现在的架构。

## 关于技术和方案选型
作者开发时会对方案可行性进行一些商酌，以下是作者的一些思考。

### Q1: 为什么采用单例模式？
用了单例模式，作者就不需要额外对插件的初始化进行去重了（说白了作者太懒了）。

目前作者采用一刀切的方式，插件初始化后就不能再对未初始化过的选项进行设置，导致初始化去重是插件级的，而不是选项级的，对细节的控制就比较粗糙了。

### Q2: 为什么采用事件总线？
作者希望核心与插件解耦，事件总线的方式很好的完成了这一点。核心不需要关心有哪些插件，它只需要等着数据来就行了；插件也不需要知道事件上报到哪，它只需要通知事件中心，让事件中心替它上报就行了。

### Q3: 为什么采用函数式 + 闭包写法？
类写法和函数式写法各有优势，首先类在管理私有变量、共享静态方法方面有着无可比拟的优势。函数式写法没有这些优势，反而还多了闭包问题。但函数式不需要那么多 this。

首先作者不喜欢类写法（所以写 Java 的时候非常痛苦）。所以作者坚持要采用函数式写法。

### Q4: 为什么 FSP 采用这样的方式计算？
FSP 并不是标准的 Web Vitals，它是基于业务的延申。对于首屏、首屏加载完成的定义随着不同的业务有很大差别。LCP 最接近 “完全加载” 这一定义，而且很容易算，于是采用 LCP 近似、并佐以特定元素渲染完成的方案来计算 FSP。

最初采用 PerformanceObserver 监听 entryType 为 'element' 的条目 + HTML 属性 elementtiming。但这个方法非常局限，只能监听 img 标签、有背景的元素、文本标签；兼容性也很完蛋，它是一个非常新的标准；其次用户需要自己去 HTML 里加上 elementtiming 属性，造成一定的侵染。

不过也许可以为这些元素动态注入 elementtiming。

### Q5: 预先设计的 XPath 选中 DOM 为什么废弃了？
作者发现它的使用频率不大，而且可以被选择器路径所替代，元素 API 对选择器路径的支持也优于 XPath，于是废弃 XPath 选中 DOM 的方案。

### 关于分级队列
监控的不同条目具有不同的上报频率，所以需要为它们设置不同的队列容量。本项目以容量和定时时间间隔的形式间接设置队列优先级。目前仍需细化，用户信息与路由追踪、点击事件目前属于同一队列，这明显是不合理的。

### 关于 ServiceWorker 缓存
最初一直显示 MIME 类型报错，发现是文件路径的问题。直接把 sw.js 放在 demo 的 public 下是正常的，但作者不能让用户自己剪切粘贴这个文件，作者觉得这有损 SDK 的封闭性、增加 SDK 的侵入性，也会让用户体验变差。于是作者通过查阅资料，最终决定采用 ESM 动态导入解决了这个问题。不过作者很快发现，即使使用动态导入成功注册，后续页面的 controller 是空的，也不能 postMessage。作者实在没招了，最终配置了命令来自动写入项目的 public 里，并采取可选的 ServiceWorker 配置选项。零侵入的目标失败力……

### 关于初始化选项
初始化选项设计需要优化，不能每次都把所有的选项都传进插件。作者计划对初始化选项进行插件分层，看看能不能打平一些嵌套。

## 成长与收获
自己设计带来了非常大的成就感，不断查阅资料的过程也让自己对一些较新的 API 有了更多接触，特别是 Performance API，还贡献了一篇翻译。对错误监听处理方面的认知也加深了，也接触到了新的性能指标 INP，接触了单例模式和发布订阅模式。

全记录下来，到时候写大作业作者可以偷点懒（
